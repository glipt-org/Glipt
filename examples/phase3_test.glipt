# Phase 3: String functions, list functions, bitwise module, error line numbers

# ---- String functions ----

# substr
assert(substr("hello world", 6) == "world")
assert(substr("hello", 0, 3) == "hel")
assert(substr("hello", -3) == "llo")
assert(substr("hello", -3, 2) == "ll")
assert(substr("hello", 10) == "")

# index_of
assert(index_of("hello world", "world") == 6)
assert(index_of("hello", "ll") == 2)
assert(index_of("hello", "xyz") == -1)
assert(index_of("hello", "") == 0)

# repeat
assert(repeat("ab", 3) == "ababab")
assert(repeat("x", 1) == "x")
assert(repeat("hi", 0) == "")

# reverse (string)
assert(reverse("hello") == "olleh")
assert(reverse("") == "")
assert(reverse("a") == "a")

# lstrip / rstrip
assert(lstrip("  hello") == "hello")
assert(lstrip("hello") == "hello")
assert(rstrip("hello  ") == "hello")
assert(rstrip("hello") == "hello")
assert(trim("  hello  ") == "hello")

# char_at
assert(char_at("hello", 0) == "h")
assert(char_at("hello", 4) == "o")
assert(char_at("hello", -1) == "o")
assert(char_at("hello", 10) == nil)

# pad_start / pad_end
assert(pad_start("hi", 5) == "   hi")
assert(pad_start("hi", 5, "0") == "000hi")
assert(pad_start("hello", 3) == "hello")
assert(pad_end("hi", 5) == "hi   ")
assert(pad_end("hi", 5, "0") == "hi000")
assert(pad_end("hello", 3) == "hello")

println("String functions: ok")

# ---- List functions ----

# reverse (list - mutating)
items = [1, 2, 3, 4]
reverse(items)
assert(items[0] == 4)
assert(items[3] == 1)
assert(len(items) == 4)

# slice
sub = slice([10, 20, 30, 40, 50], 1, 3)
assert(len(sub) == 2)
assert(sub[0] == 20)
assert(sub[1] == 30)

# slice with negative index
sub2 = slice([10, 20, 30, 40, 50], -2)
assert(len(sub2) == 2)
assert(sub2[0] == 40)

# insert
items = [1, 2, 3]
insert(items, 1, 99)
assert(items[1] == 99)
assert(items[2] == 2)
assert(len(items) == 4)

# find
assert(find([10, 20, 30], 20) == 1)
assert(find([10, 20, 30], 99) == -1)
assert(find(["a", "b", "c"], "b") == 1)

# remove
items = [10, 20, 30, 40]
removed = remove(items, 1)
assert(removed == 20)
assert(len(items) == 3)
assert(items[1] == 30)

println("List functions: ok")

# ---- Bitwise module ----

assert(bit.and(255, 15) == 15)
assert(bit.or(160, 15) == 175)
assert(bit.xor(255, 15) == 240)
assert(bit.lshift(1, 8) == 256)
assert(bit.rshift(256, 4) == 16)
assert(bit.not(0) == 4294967295)
assert(bit.and(bit.lshift(1, 4), 255) == 16)

println("Bitwise module: ok")

# ---- Error line numbers ----

allow exec "*"
on failure {
    assert(error.message != nil)
    assert(error.type == "exec")
    assert(error.line != nil)
    assert(error.line > 0)
    println(f"Error line numbers: ok (caught error at line {error.line})")
}
exec "nonexistent_command_that_does_not_exist_xyz"

# ---- env() with default ----

allow env "*"
assert(env("TOTALLY_NONEXISTENT_VAR_XYZ") == nil)
assert(env("TOTALLY_NONEXISTENT_VAR_XYZ", "fallback") == "fallback")
assert(env("TOTALLY_NONEXISTENT_VAR_XYZ", 42) == 42)
home = env("HOME", "/tmp")
assert(len(home) > 0)

println("env() default: ok")

# ---- Range as real values ----

# 1..5 produces a usable list
r = 1..5
assert(type(r) == "list")
assert(len(r) == 4)
assert(r[0] == 1)
assert(r[3] == 4)

# Assign, pass around, index into
nums = 0..3
assert(contains(nums, 0) == true)
assert(contains(nums, 2) == true)
assert(contains(nums, 3) == false)

# Works with expressions
start = 5
end = 10
r2 = start..end
assert(len(r2) == 5)
assert(r2[0] == 5)
assert(r2[4] == 9)

# Use in for-in (still works)
total = 0
for i in 1..4 {
    total += i
}
assert(total == 6)

# map/filter over a range
doubled = map_fn(1..5, fn(x) { return x * 2 })
assert(len(doubled) == 4)
assert(doubled[0] == 2)
assert(doubled[3] == 8)

println("Range values: ok")

# ---- Math module additions ----

assert(math.log2(8) == 3)
assert(math.log2(1) == 0)
assert(math.trunc(3.7) == 3)
assert(math.trunc(-3.7) == -3)
assert(math.sign(42) == 1)
assert(math.sign(-5) == -1)
assert(math.sign(0) == 0)

# Variadic min/max
assert(math.min(3, 1, 2) == 1)
assert(math.max(3, 1, 2) == 3)
assert(math.min(5) == 5)
assert(math.max(10, 20, 5, 15) == 20)

println("Math additions: ok")

# ---- sort() with strings and comparator ----

# Sort strings
words = ["banana", "apple", "cherry"]
sort(words)
assert(words[0] == "apple")
assert(words[1] == "banana")
assert(words[2] == "cherry")

# Sort with custom comparator (descending)
nums = [3, 1, 4, 1, 5]
sort(nums, fn(a, b) { return b - a })
assert(nums[0] == 5)
assert(nums[1] == 4)

# Sort numbers (still works)
nums2 = [30, 10, 20]
sort(nums2)
assert(nums2[0] == 10)
assert(nums2[2] == 30)

println("sort() improved: ok")

# ---- count(), capitalize() ----

assert(count("hello world hello", "hello") == 2)
assert(count("aaa", "a") == 3)
assert(count("abc", "xyz") == 0)

assert(capitalize("hello") == "Hello")
assert(capitalize("HELLO") == "Hello")
assert(capitalize("") == "")
assert(capitalize("a") == "A")

println("count/capitalize: ok")

# ---- is_number(), is_alpha() ----

assert(is_number("123") == true)
assert(is_number("12a") == false)
assert(is_number("") == false)
assert(is_number("0") == true)

assert(is_alpha("hello") == true)
assert(is_alpha("hello1") == false)
assert(is_alpha("") == false)
assert(is_alpha("ABC") == true)

println("is_number/is_alpha: ok")

# ---- sum(), unique() ----

assert(sum([1, 2, 3, 4]) == 10)
assert(sum([]) == 0)
assert(sum([1.5, 2.5]) == 4)

u = unique([1, 2, 2, 3, 3, 3])
assert(len(u) == 3)
assert(u[0] == 1)
assert(u[1] == 2)
assert(u[2] == 3)

u2 = unique(["a", "b", "a", "c", "b"])
assert(len(u2) == 3)
assert(u2[0] == "a")

println("sum/unique: ok")

println("Phase 3: ALL PASSED")
